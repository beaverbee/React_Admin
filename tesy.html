<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script >
    // 闭包的一个例子
//     const name=function(params) {
//         let a=1;
//         return function(){
//             a++;
//             console.log(a);
//         }
//     }

//    var exp=null;
// //    typeof exp==object 向下兼容
//     var exp1=undefined
//    console.log(typeof exp=='undefined');
//    console.log(exp===null, exp1===null);//true false 采用===可以判别undefined 和null
//    console.log(exp==null,exp1==null)//true true 
// //    type exp1=='undefined' typeof饭返回的是字符串 不是对象or变量本身
//    console.log(typeof exp1);
// //    ps:在js中==会对数据类型进行比较 如果不相同会进行转换再进行比较 
// //       但===需要同时比较数据类型以及数据值
// // ps: typeof NaN ==number
// const str='123.png'
// console.log(str.search(/\w(\.jpg)/));
// const a=[1,[2,3],4,[5,[6,7]]];
// const menu=(menulist)=>{
//     return menulist.reduce((pre,cur)=>{
//         if(typeof cur!=="object"){
//             pre=[...pre,cur]
//             return pre
//         }else{
//             pre=[...pre,menu(cur)]
//             return pre
//         }
//     },[])
// }

// const b=[2,3]
// // const c=b.reduce((pre,cur)=>{ return pre=[...pre,cur]},[])
// console.log(menu(a));
// 在使用reduce中会出现的一个bug 就是pre返回的是一个值 
const d=[1,2,3,4,5]
const e=d.reduce((pre,cur)=>{debugger; return pre.push(cur)},[])
console.log(e);
    


</script>
</html>